\documentclass[12pt,a4paper]{report}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{newlfont}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {./pic/} }

\begin{document}

\begin{titlepage}
  \begin{center}
    {{
      \Large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di Bologna}}
    }} \rule[0.1cm]{15.8cm}{0.1mm}
    \rule[0.5cm]{15.8cm}{0.6mm}
    {\small{\bf SCUOLA DI SCIENZE\\
    Corso di Laurea in Informatica}}
  \end{center}
  \vspace{15mm}
  \begin{center}
    {\LARGE{\bf LA MIA FANTASTICA}}\\
    \vspace{3mm}
    {\LARGE{\bf OTTIMISTICA}}\\
    \vspace{3mm}
    {\LARGE{\bf TESI}}\\
  \end{center}
  \vspace{40mm}
  \par
  \noindent
  \begin{minipage}[t]{0.47\textwidth}
  {\large{\bf Relatore:\\
  Chiar.mo Prof.\\ % TODO 
  Claudio Sacerdoti Coen}}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.47\textwidth}\raggedleft
  {\large{\bf Presentata da:\\
  Mattia Girolimetto}}
  \end{minipage}
  \vspace{20mm}
  \begin{center}
  {\large{\bf I Appello di Laurea\\%inserire il numero della sessione in cui ci si laurea
  Anno Accademico 2022-2023}}%inserire l'anno accademico a cui si è iscritti
  \end{center}
\end{titlepage}


\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduzione}

\chapter{Proof Assistant e Interoperabilità}

\section{La Teoria dei Tipi}
\subsection{Il paradosso di Russel}
Quando il matematico inglese Bertrand Russel propose il paradosso oggi chiamato a suo 
nome, nei primi anni del $'900$ scatenò quella che venne definita \textit{crisi
dei fondamenti matematici}. Il paradosso semplicemente evidenziava come la teoria
degli insiemi usata fino a quel punto (oggi definita teoria degli insiemi \textit{naive})
rendesse possibile definire un insieme come il seguente
\begin{center}
  $X = \{Y | Y \notin Y \}$
\end{center}

La contraddizione avviene quando ci si domanda se $X \in X$, in quanto se $X$ appartenese
a sé stesso allora non apparterrebbe all'insieme degli insiemi che appartengono loro stessi,
ovvero $X$ stesso. In formule:
\begin{center}
  $X \in X \Leftrightarrow X \notin X$
\end{center}

Una delle strategie pensate dunque per aggirare questo paradosso fu la \textit{teoria dei tipi}.

\subsection{La Teoria dei Tipi}
La \textit{teoria dei tipi} è una branca della matematica, della logica, dell'informatica
teorica il cui obbiettivo è quello di studiare i così detti \textit{type system}, ovvero
insiemi di regole che associano una proprietà chiamata \textit{tipo} ad degli oggetti
chiamati \textit{termini}. Nonostante siano state proposte molteplici teorie, le principali
emerse sono due: il \textit{$\lambda$-calcolo tipato} di Alonozo Church e la \textit{teoria
dei tipi intuizionistica} di Per Martin-L{\"o}f.

Intuitivamente, assegnare un tipo ad un termine significa assegnare al termine un'etichetta
che rappresenta la natura del termine stesso. Esempi comuni possono essere: 
\begin{itemize}
  \item $42$ è un numero naturale 
  \item $-5$ è un numero intero
  \item $falso$ è un valore di verità 
\end{itemize}

Formalmente si usa rappresentare queste espressioni separando il termine dal tipo usando
il simbolo '$:$'. Gli esempi precedenti diventano quindi:
\begin{itemize}
  \item $42$ $:$ $\mathbb{N}$
  \item $-5$ $:$ $\mathbb{Z}$
  \item $falso$ $:$ $\mathbb{B}$ 
\end{itemize}

Nella teoria dei tipi, anche le funzioni sono termini e possono essere
a loro volta tipizzate. Ad esempio, la seguente funzione rappresentata con un $\lambda$-termine
appartenente al $\lambda$-calcolo di Church 
\begin{center}
  $(\lambda$ $x$ $:$ $\mathbb{N}$ $.$ $x + x)$
\end{center}

è definita da $\mathbb{N}$ a $\mathbb{N}$, e per tanto ha tipo $\mathbb{N} \rightarrow \mathbb{N}$

\subsection{L'isomorfismo di Curry-Howard}
Sempre durante il '900 i logici Haskell Curry e William Alvin Howard, scoprirono
una corrispondenza diretta tra prove formali e programmi. In particolare notarono
che gli operatori logici e le regole usate durante una dimostrazione formale
sono equivalenti a tipi e costrutti usati nei programmi scritti usando linguaggi
di programmazione funzionali. Ne segue che il verificare la correttezza di una
prova è analogo al verificare la correttezza degli assegnamenti di tipo di un
programma (\textit{type checking}). Nella sua formulazione più generale,
l'isomorfismo di Curry-Howard può essere riassunto con la seguente tabella:

\begin{center}
  \begin{tabular}{ | c | c |}
    \hline
    \textbf{Logica} & \textbf{Informatica} \\
    \hline
    $\top$ & Tipo unit \\
    \hline
    $\bot $ & Tipo vuoto/void \\
    \hline
   $\wedge$ & Tipi prodotto \\  
    \hline
   $\vee$ & Tipi somma \\
    \hline
   $\Rightarrow$ & Tipi funzione \\ 
    \hline
   $\exists$ & Tipi $\Sigma$ \\ 
    \hline
    $\forall $ & Tipi $\Pi$ \\ 
    \hline

  \end{tabular}
\end{center}

\subsection{La teoria dei tipi nella pratica}
La teoria dei tipi trova quindi grande applicazione nel campo dell'informatica
grazie allo studio e allo sviluppo dei linguaggi di programmazione. Inoltre,
grazie all'isomorifismo di Curry-Howard, ha permesso lo sviluppo di dimostratori
automatici di teoremi e di dimostratori interattivi di teoremi, i quali sono
soggetto di questa tesi.

\section{Dimostratori Interattivi di Teoremi}
Un dimostratore interattivo di teoremi (o \textit{proof assistant}) è un software 
che permette all'utente di costruire e verificare delle dimostrazioni matematiche
formali. Presa in input una prova espressa utilizzando uno specifico linguaggio 
formale, simile ad un linguaggio di programmazione, il software è in grado di
verificarne la correttezza. In questo modo si possono costruire dimostrazioni
in modo interattivo, controllando progressivamente la corretezza di ogni passo.
Uno dei benefici chiave dell'usare un dimostratore interattivo automatico è l'
abilità di eliminare gli errori e le ambiguità che possono comparire nelle 
dimostrazioni tradizionali.

\subsection{Matita}
Matita è un  proof assistant in sviluppo nel dipartimento di informatica dell'
Università di Bologna. E' open source, scritto nel linguaggio di programmazione 
OCaml ed è rilasciato secondo i termini della GNU General Public Licence.
E' basato sul \textit{calcolo delle costruzioni (co)induttive}, una teoria di tipi
dipendenti che estende il \textit{calcolo delle costruzioni} sviluppato da
Thierry Coquand aggiungendo i tipi induttivi, ovvero tipi autoreferenzianti.


\subsection{Dedukti}
Dedukti\footnote{"dedurre" in esperanto} è un \textit{logical framework}
sviluppato da alcuni ricercatori del \textit{Institut national de recherche
en informatique et en automatique} francese. Il software è open source, anch'esso
scritto nel linguaggio di programmazione OCaml e distribuito secondo i termini
della CeCILL-B License. Uno degli obbiettivi principali di Dedukti è creare una
connessione tra i diversi sistemi di dimostrazione assistita al computer. Ciò
significa che le dimostrazioni possono essere tradotte da un sistema all'altro,
agevolando lo scambio e il riutilizzo delle dimostrazioni tra ambienti di lavoro
diversi. Alcuni proof system, come ad esempio Coq e Hol Lite 
\footnote{Coq: https://github.com/Deducteam/CoqInE,\\ HOL Lite: https://arxiv.org/pdf/1507.08720.pdf}
godono infatti della possibilità di esportare e importare codice da e verso Dedukti.

Si basa sul $\lambda\pi$-calcolo, un'estensione del 
$\lambda$-calcolo che introduce la tipizzazione dipendente, consentendo la
specifica di tipi complessi che dipendono dai valori delle espressioni. Questa
caratteristica lo rende un potente strumento per la verifica formale e la
dimostrazione assistita tramite proof assistant.

\section{Interoperabilità Dedukti-Matita}

\subsection{Interoperabilità tra sistemi}
Il numero di proof assistant è aumentato nel tempo. Ciò porta sicuramente un
beneficio alla comunità scientifica, in quanto dimostra un crescente interesse
verso lo sviluppo di questi strumenti. Tuttavia, unito alla forte diversità che
li caratterizza individualmente, questo fenomeno porta inevitabilmente
ad una \textit{frammentazione} della conoscenza. Non è quasi mai possibile infatti
per un utente dimostrare la veridicità di un teorema usando un proof assistant
e usare la stessa dimostrazione in un altro di questi tool. Il problema è dovuto
a fattori facilmente aggirabili, come ad esempio la differenza sintattica dei due
linguaggi proprietari, ma anche a fattori non facilmente aggirarabili, come nel
caso in cui i due tool usino calcoli con diversi livelli di espressività.

Nasce dunque l'esigenza di favorire l'interoperabilità tra questi sistemi, in
modo da arginare questo problema e favorire lo sviluppo scientifico. 
A tale scopo, nel tempo sono state aggiunte ad alcuni di tool delle funzionalità
di export, per permettere all'utente di ottenere la propria dimostrazione in un
formato compatibile con un altro software.

\chapter{Da Matita a Dedukti} \label{capitoloExport}
\section{Krajono}
Attorno al 2018 un team di sviluppatori del 
\textit{Institut national de recherche
en informatique et en automatique} %TODO check 
ha sviluppato un fork di Matita con la possibilità di esportare le dimostrazioni
in un formato compatibile con Dedukti. Questo fork è tutt'ora distribuito 
pubblicamente con il nome di \textit{Krajono} ("matita" in esperanto) anche se 
non è stato aggiornato con gli ultimi sviluppi del Matita baseline.
Il primo passo del mio lavoro è stato quello di integrare il codice di Krajono
dentro a Matita.

\subsection{Funzionamento dell'esportazione}
Il processo di esportazione prevede l'analisi del tipo e della struttura di 
ciascuna istruzione del file Matita. Queste passano per un processo di 
\textit{scanning} e \textit{parsing}, fino a diventare oggetti contenenti i
termini, in un albero astratto. Questi vegono poi passati singolarmente al
modulo responsabile per la conversione. Durante questo processo vengono
analizzate la struttura e le caratteristiche di ciascun termine, per poi
costruirne uno o più rappresentanti istruzioni Dedukti. La traduzione cerca 
di essere dove possibile una trasformazione uno a uno, anche se come si vedrà
nella sezione \ref{ProblemiKrajono} non sempre è possibile.

\subsection{Export da linea di comando}
Matitac è il compilatore da linea di comando di Matita. Se lo si lancia compila
tutti i file con estensione \textit{.ma} presenti nella directory corrente. 
Opzionalmente, passando come argomento il nome di un file, è possibile anche 
compilarlo singolarmente. 

Krajono fornisce la possibilità di esportare il codice Matita specificando l'
argomento \texttt{-extract\_dedukti} a Matitac, sia lavorando con un unico file,
sia con un'intera directory. Successivamente si potranno trovare i file \textit{.dk} 
relativi al codice matita esportato nella directory dei sorgenti.

\subsection{Integrazione in Matita}
Per integrare le funzionalità di Krajono in Matita al posto di aprire una \textit{
pull request} da una repository Git all'altra, si è preferito copiare e addattare i
singoli file sorgente responsabili dell'esportazione. Questo in quanto utilizzare
lo strumento di versionamento automatico avrebbe portato delle complicazioni in
quanto Krajono non è basato direttamente sul Matita baseline, ma su un ulteriore
fork \footnote{https://github.com/LPCIC/matita}. Inoltre Krajono, al momento della
stesura di questa tesi, non è più mantenuto da anni. 

\paragraph{Struttura del sorgente}
In codice sorgente responsabile dell'esportazione è diviso in tre moduli OCaml:
\begin{itemize}
  \item \textit{dedukti}: contenente le definizioni di costanti e funzioni
    di utilità.
  \item \textit{deduktiExtraction}: contenente la logica del vero e proprio 
    export.
  \item \textit{deduktiPrint}: contenente semplici funzioni per stampare a 
    schermo gli oggetti usati nell'export.
\end{itemize}

Durante la compilazione di un file, quando il flag \texttt{-extract\_dedukti} è
attivo, il motore di Matita/Krajono avvia l'esportazione chiamando una funzione
dal modulo \texttt{deduktiExtraction} durante la fase di costruzione dell'albero
astratto.

\paragraph{Integrazione}
Il codice interessato dunque è poco dipendente dal resto del codice di Matita,
quindi il porting della funzionalità si è ridotto al copiare i file da un progetto
all'altro e modificare dove necessario. Ora è possibile avviare l'export tramite
lo stesso flag di Matitac presente in Krajono.


\section{Problemi di Krajono} \label{ProblemiKrajono}
Essendo il linguaggio di Dedukti meno espressivo del 

% 1. Come invocare krajono per produrre i file dk
% 2. Integrare Krajono: come krajono è stato strutturato e come l'ho integrato
% 3. Come funziona l'export di Krajono?
% 4. Drawbacks dell'exporting


\chapter{Da Dedukti a Matita}
Come visto nel capitolo precedente, usando Krajono è possibile esportare 
del codice Matita verso Dedukti, tuttavia non è possibile fare il contrario,
in quanto ne Krajono, ne Dedukti stesso godono di questa funzionalità.
L'export è dunque a senso unico, e qualcosa di esportato non può essere
re-importato in Matita. Il lavoro di questa tesi è proprio il seguente:
rendere Matita capace di esportare ed importare codice da e verso Dedukti.
Con un export a doppio senso gli sviluppatori Matita saranno in grado 
di usare dimostrazioni Dedukti e vice versa.

\section{Il parser Dedukti} \label{parserDedukti}
% TODO
% spiegare che dedukti è diventato dipendenza

\section{Tradurre i termini Dedukti}
Alcuni termini Dedukti sono direttamente traducibili in termini Matita. Alcuni
invece richiedono una logica più complessa.

\paragraph{Costanti}
Per tradurre le costanti è stato necessario semplicemente convertire il nome
Dedukti in un \textit{uri} Matita. Per evitare conflitti con i nomi si è aggiunto
anche una tabella hash che per tenere traccia dei nomi già assegnati e dei 
relativi uri.

\paragraph{Indici di De Brujin}
Entrambi i software fanno uso degli indici di De Brujin, una rappresentazione
compatta delle variabili legateall'interno di un termine. Sono utilizzati per
semplificare la manipolazione dei termini, eliminando la necessità di utilizzare
nomi unici per le variabili e consentendo di eseguire operazioni come la 
sostituzione e il confronto tra termini in modo efficente. 
Essendo un indice rappresentato da un intero la conversione è stata diretta.
L'unica accortezza presa è stata l'aggiungere $1$ ad ogni indice in quanto
Matita fa uso di un sistema \textit{$1$ based} mentre Dedukti conta partendo
da $0$.

\paragraph{$\beta$-riduzione}
In Dedukti il passo di $\beta$-riduzione è rappresentato tramite una tripla
contenente: 
\begin{itemize}
  \item Un termine rappresentante la $\lambda$ astrazione da ridurre
  \item Un termine rappresentante il primo argomento da usare per la riduzione
  \item Una lista di termini rappresentante il resto degli argomenti
\end{itemize}
Per tradurlo è stato sufficente tradurre individualmente, ricorsivamente, ciasucno
di questi termini, e riassemblarli costruiendo un oggetto che rappresenta la 
$\beta$-riduzione in Matita. 
L'esportazione del capitolo \ref{capitoloExport} utilizza delle particolari
definizioni per rappresentare alcuni termini di Matita %TODO all the cic.stuff

\paragraph{$\lambda$-astrazione e prodotto}
Astrazioni lambda e prodotti condividono la stessa struttura e per tanto sono
rappresentati allo stesso modo sia in Dedukti che in Matita.
Nel primo sono rappresentati come una tupla contenente
\begin{itemize}
  \item Un identificativo Dedukti
  \item Un termine rappresentante il tipo della $\lambda$-astrazione o del prodotto
  \item Un termine rappresentante il corpo
\end{itemize}
Si costruiscono quindi i relativi oggetti Matita convertendo l'identificativo
e traducendo ricorsivamente il tipo e il corpo.

\paragraph{Type e Kind}
Il calcolo lambda-pi usa i concetti di \textit{type} e \textit{kind}: type è
il classico \textit{concetto di tipo} usato per la classificazione di termini,
mentre kind è un tipo speciale rappresentante il tipo di tutti i tipi. Ad 
esempio 5 può avere tipo $nat$, mentre $nat$ porebbe avere kind $*$. Nel 
calcolo delle costruzioni (co)induttive alla base di Matita questi concetti
non sono presenti, e per tanto non sono stati tradotti. %TODO add info about sort and univs

\section{Invertire l'esportazione}
Fino adesso è stato visto come importare in Matita del codice Dedukti semplice,
tuttavia, se si volesse importare del codice precedentemente esportato usando
la funzionalità del capitolo \ref{capitoloExport}, ci si accorgerebbe della 
scomparsa di alcuni costrutti Matita, come ad esempio il \textit{match}. Questo
perché, dato che Dedukti non li possiede, durante l'esportazione sono stati
trasformati in termini che ne emulano il comportamento. Per rendere dunque possibile
la costruzione di un codice quanto più vicino all'originale si ha pensato ed 
implementato la strategia qua successivamente discussa.

\subsection{L'uso delle pragma}
Il linguaggio di Dedukti da la possibilità all'utente di scrivere delle 
\textit{direttive} o \textit{pragma}. Queste sono delle particolari righe di
codice interpretate dal compilatore e che per tanto non fanno parte del programma.
Usandole è possibile istruire il compilatore Dedukti, o nel nostro caso il parser
Dedukti integrato dentro Matita \ref{parserDedukti}, affinché agisca in determinati
modi quando le incontra. 
Nel caso specifico di questa tesi, sono state definite ed usate delle pragma
per indicare quali parti di codice Dedukti fanno riferimento ad un costrutto 
Matita andato perso durante l'esportazione.

\subsection{Punto fisso}


\chapter{Conclusioni}

\chapter{Sviluppi futuri}



% bio
% http://www.cs.unibo.it/~ricciott/PAPERS/system_description2011_draft.pdf
\end{document}
